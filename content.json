{"meta":{"title":"大力","subtitle":"出奇迹","description":"Dali|大力|博客|个人","author":"大力","url":"http://dali.com","root":"/"},"posts":[{"tags":[],"title":"Hello World","date":"2022/06/12","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","permalink":"http://dali.com/2022/06/12/Helloworld/","photos":[]},{"tags":[],"title":"前端性能监控","date":"2022/04/03","text":"为什么需要性能监控 拥有统一的指标（标准）来衡量我们页面的一个渲染、交互情况 随着业务或者技术的发展，我们对基础架构的升级：比如说接入了node-ssr，升级了webpack的打包策略，使用workbox)，这些改造对于我们的我们当前页面的影响 性能监测从技术侧更好的优化页面，提高pv率，提高用户体验 工具 开发者面板 lighthouse webpagetest 基本框架 PerformanceObserver()： 异步的 performance.timing : 同步的时间，白屏的时间，dns的握手 caniuse-lit 对api支持度的包 初始化参数 1234567new SDk({ logUrl: string // 上报地址 isResourceTiming： analyticsTracker： isElementTiming： maxTime： }) TTFB TTFB = 重定向时间 + servicework + dns查询+ tcp + responseStart onload 或者 document.readyState === ‘complete’ 后，加入到宏任务 123addEventListener('load', () =&gt; setTimeout(()=&gt; {const value = performance.getEntriesByType('navigation')[0].responseStart}, 0)); 异常数据禁止上报： 123if (metric.value &lt; 0 || metric.value &gt; performance.now()) { return} 通用的observe 12345678910111213141516export const po = ( eventType: IPerformanceObserverType, cb: (performanceEntries: any[]) =&gt; void): PerformanceObserver | null =&gt; { try { const perfObserver = new PerformanceObserver((entryList) =&gt; { cb(entryList.getEntries()); }); // 订阅时间或者开始计时 buffered不立即执行在内存中留下PerformanceObserver实例 perfObserver.observe({ type: eventType, buffered: true }); return perfObserver; } catch (e) { C.warn('监控error:', e); } return null;}; fcp、fp 12345678910111213141516po('paint', initFirstPaint)export const initFirstPaint = (performanceEntries: IPerformanceEntry[]) =&gt; { performanceEntries.forEach((entry) =&gt; { if (entry.name === 'first-paint') { console.log('香蕉🍌--》', performanceEntries) logMetric(entry.startTime, 'fp'); } else if (entry.name === fcpEntryName) { fcp.value = entry.startTime; logMetric(fcp.value, 'fcp'); // TBT 是fcp到tti中间的超过50ms的长任务的总和 perfObservers[4] = po('longtask', initTotalBlockingTime); // 去除连接 poDisconnect(0); } });}; tbt fcp到tti之间之间长任务的时间总和 注意点： 不统计浏览器本身的 事件循环本身 https://w3c.github.io/longtasks/ 12345678910111213141516 po('longtask', initTotalBlockingTime); initTotalBlockingTime = ( performanceEntries: IPerformanceEntry[]): void =&gt; { performanceEntries.forEach((entry) =&gt; { //从fcp -&gt; tti获取长耗时任务（self表示耗时长任务来自于渲染帧） if (entry.name !== 'self' || entry.startTime &lt; fcp.value) { return; } //长耗时任务意味着执行时间超过50ms的 const blockingTime = entry.duration - 50; if (blockingTime &gt; 0) { tbt.value += blockingTime; } });}; // 何时上报: 在fid指标获取后 1234setTimeout(() =&gt; { logMetric(tbt.value, `tbt5S`); }, 0); fid（第一次输入延迟） FID 测量从用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应，并实际能够开始处理事件处理程序所经过的时间。 实际发生的行为，只能根据响应的时间进行 1234567891011121314151617 po('first-input', initFirstInputDelay); const initFirstInputDelay = ( performanceEntries: PerformanceEventTiming[]) =&gt; { //取最后的一位即为我们希望所获取的时间点 console.log('ghahhahahha--&gt;', performanceEntries) const lastEntry = performanceEntries.pop(); if (lastEntry) { // Core Web Vitals FID logic // 测量输入事件的延迟操作 logMetric(lastEntry.processingStart - lastEntry.startTime, 'fidVitals', { performanceEntry: lastEntry, }); } // 销毁对FID的注册回调 避免过多的观察者造成内存泄露 poDisconnect(1);} 何时上报: 在fid指标获取后 lcp 当用户与页面进行交互（通过轻触、滚动或按键）时，浏览器将立刻停止报告新条目，因为用户交互通常会改变用户可见的内容（滚动操作时尤其如此） 12345678export const initLargestContentfulPaint = ( performanceEntries: IPerformanceEntry[]) =&gt; { const lastEntry = performanceEntries.pop(); if (lastEntry) { lcp.value = lastEntry.renderTime || lastEntry.loadTime; }}; 资源监控 po(‘resource’, initResourceTiming); layout-shift https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift hadRecentInput: 500ms内用户输入导致的位移不计入意外位移 123456export const initLayoutShift = (performanceEntries: IPerformanceEntry[]) =&gt; { const lastEntry = performanceEntries.pop(); if (lastEntry &amp;&amp; !lastEntry.hadRecentInput &amp;&amp; lastEntry.value) { cls.value += lastEntry.value; }}; 上报工具 img的src sendBeach 何时上传 pageshow pagehide window.requestAnimationFrame window.requestIdleCallback 用户离线了 数据无法上报 offline.js 源码 我的源码链接，欢迎fork","permalink":"http://dali.com/2022/04/03/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/","photos":[]}],"categories":[],"tags":[]}